⸻

Computer Networks Assignment 2

Authors:

Tejas Lohia
Umang Shikarvar

⸻

JSON File Overview

Part	JSON File(s)	Generated By	Contents
PART_B	1PCAP.json, 2PCAP.json, …	host.py (default resolver)	Contains per-domain resolution results using the system’s default resolver. Each file records total queries, success and failure counts, average latency, and throughput. The details section lists every domain with its resolution status (SUCCESS or FAILED) and the resolved name.
PART_D	PCAPX.json (in Resolver_no_cache_singleserver/)	customresolver.py and host.py	Contains the output of the custom DNS server when caching is disabled. Each entry includes timestamps, total statistics, and detailed per-query results with the full DNS resolution path.
PART_E	PCAPX_cache_multiserver.json (in Resolver_Multiserver/)	customDNS_cache.py	Contains results of multi-server experiments with caching enabled. Stores query-wise data including cache hits, resolution times, and comparison metrics with and without cache. This is the final JSON file that integrates all components.


⸻

Table of Contents
	•	Overview
	•	Setup Instructions
	•	Directory Structure
	•	Part Breakdown
	•	PART_A: Network Topology Setup
	•	PART_B: Default Resolver Experiments
	•	PART_C: Custom DNS Resolver
	•	PART_D: Custom DNS Server + Host Interface
	•	PART_E: Multiserver, No-Cache, and Post-Processing
	•	textfiles: Input Domain Lists
	•	How to Run
	•	Analysis and Results
	•	Troubleshooting
	•	References

⸻

Overview

This project investigates the working of DNS resolution within a simulated network using Mininet.
It focuses on three main aspects:
	1.	Measuring performance of the system’s default DNS resolver,
	2.	Building a custom iterative DNS resolver, and
	3.	Extending it into a multi-server resolver with caching.

The analysis includes latency, throughput, and cache hit ratios across multiple scenarios.

⸻

Setup Instructions
	1.	Clone the repository

git clone <repo_link_here>
cd CN_ASSIGNMENT2


	2.	Install Mininet and dependencies

git clone https://github.com/mininet/mininet.git
cd mininet
sudo ./util/install.sh -a


	3.	Set up a Python virtual environment

python3 -m venv mn-venv
source mn-venv/bin/activate
pip install -r requirements.txt


	4.	Launch Mininet topology
	•	Scripts for both NAT and non-NAT configurations are provided in PART_A.

⸻

Directory Structure

CN_ASSIGNMENT2/
│
├── PART_A/                # Network topology setup scripts
├── PART_B/                # Default DNS resolver experiment + statistics
├── PART_C/                # Custom DNS resolver implementation
├── PART_D/                # Custom DNS server and host interface
├── PART_E/                # Multiserver and caching experiments
├── textfiles/             # Domain lists derived from PCAPs
│
└── customDNSresolver.py   # Combined resolver/server implementation


⸻

Part Breakdown

PART_A: Network Topology Setup
	•	codewithnat.py and codewithoutnat.py
Used to configure the Mininet network, either with NAT (for internet access) or without.
	•	commands.txt, README.md
Contain additional setup commands and notes.

⸻

PART_B: Default Resolver Experiments
	•	host.py
Runs on each host in Mininet. Reads domain names from files such as temp_h1.txt and resolves them using the system’s default resolver (socket.getaddrinfo).
The system resolver forwards DNS queries to 10.0.0.6 as configured in /etc/resolv.conf.
	•	Output JSON Files: 1PCAP.json, 2PCAP.json, …
Each file contains:
	•	Total number of queries processed
	•	Successful and failed resolutions
	•	Average lookup latency and throughput
	•	Detailed per-domain results including domain name, resolution status, and resolved IPs

These files form the baseline for comparison with the custom resolver.

⸻

PART_C: Custom DNS Resolver
	•	DNS_custom.py
Implements a custom iterative DNS resolver that directly queries the DNS hierarchy starting from root servers.
Used to compare against the system resolver’s performance in terms of latency and query success rate.

⸻

PART_D: Custom DNS Server + Host Interface
	•	customresolver.py
Acts as a DNS server that receives queries from Mininet hosts and performs iterative resolution on their behalf.
	•	host.py
Sends DNS queries to the custom server over UDP.
	•	Output JSON Files: stored in Resolver_no_cache_singleserver/
Example: PCAPX.json
These files contain all things asked in Part D of the question.
	•	Query-level timestamps and resolution paths
	•	End-to-end latency per query
	•	Summary of total queries and failures
	•	No caching applied — every query is resolved from scratch.

⸻

PART_E: Multiserver, No-Cache, and Post-Processing
	•	customDNS_cache.py
Extends the DNS resolver to use multiple servers in parallel and enables caching to improve performance.
Caching reduces redundant lookups and improves throughput.
	•	Output JSON Files: stored in Resolver_Multiserver/
Example: PCAPX_cache_multiserver.json
Each file includes again what has been asked in part D
	•	Query results with timestamps
	•	Cache hit/miss statistics
	•	Response times for cached vs non-cached queries
	•	Comparison metrics with the no-cache setup from PART_D

These are the final output files used for performance analysis and plotting.

⸻

textfiles: Input Domain Lists

Files such as temp_h1.txt, temp_h2.txt, etc., contain domain names extracted from packet captures (PCAPs).
They serve as the input for both the default resolver and custom resolver experiments.

⸻

How to Run

1. Default Resolver Experiment (PART_B)

python host.py temp_h1.txt

2. Custom DNS Server Experiment (PART_D)

Start the server on the DNS node:

python customresolver.py

Then run on each host:

python host.py temp_h1.txt

3. Multiserver + Cache Experiment (PART_E)

python customDNS_cache.py


⸻

Analysis and Results
	•	Latency, throughput, and cache efficiency are computed from the JSON outputs.
	•	Default resolver shows lower latency due to internal OS-level caching.
	•	Custom iterative resolver is slower but transparent.
	•	Multi-server cached version improves latency and throughput significantly.

All plots and tables are derived from these JSON logs and presented in the report.

⸻

Troubleshooting
	•	If Mininet setup fails, reinstall using the latest branch.
	•	Ensure correct /etc/resolv.conf configuration on hosts.
	•	Verify that the DNS server process is running on the correct IP and port.
	•	Check that caching is correctly toggled when comparing experiments.

⸻

References
	•	Mininet Project
	•	dnslib Python Library
	•	Assignment Report: 23110335_301.pdf
	•	Source scripts across PART_A to PART_E directories

⸻
